// src/views/admin/AdminAssign.jsx
import React, { useEffect, useMemo, useState } from 'react'

// --- optional Supabase detection (graceful fallback to localStorage) ---
const supa = (typeof globalThis !== 'undefined' && globalThis.supabase && typeof globalThis.supabase.from === 'function')
  ? globalThis.supabase
  : null;
const hasSupa = !!supa;

/** ---------- storage helpers ---------- */
function readSales(){ try{ return JSON.parse(localStorage.getItem('sales')||'[]') }catch{ return [] } }
function writeSales(rows){ localStorage.setItem('sales', JSON.stringify(rows)) }

function readAvail(){ try{ return JSON.parse(localStorage.getItem('availability')||'[]') }catch{ return [] } }

function readUsers(){ try{ return JSON.parse(localStorage.getItem('users_seed')||'[]') }catch{ return [] } }

function readAssignments(){ try{ return JSON.parse(localStorage.getItem('assignments')||'[]') }catch{ return [] } }
function writeAssignments(rows){ localStorage.setItem('assignments', JSON.stringify(rows)) }

function readNeighborhoods(){ try{ return JSON.parse(localStorage.getItem('neighborhoodAssignments')||'[]') }catch{ return [] } }
function writeNeighborhoods(rows){ localStorage.setItem('neighborhoodAssignments', JSON.stringify(rows)) }

/** NEW: worker completion records (from worker app) */
function readJobFinishes(){ try{ return JSON.parse(localStorage.getItem('jobFinishes')||'[]') }catch{ return [] } }

const DAYS = ['Mon','Tue','Wed','Thu','Fri','Sat','Sun']

/** ---------- date helpers ---------- */
const fmtDateOnly = (t) => {
  if(!t) return '-'
  const d = typeof t === 'number' ? new Date(t) : new Date(String(t))
  if (isNaN(d.getTime())) return '-'
  return d.toLocaleDateString([], {month:'short', day:'numeric'})
}

function isFuture(ts){
  if(!ts) return false
  const val = new Date(ts).getTime()
  if (Number.isNaN(val)) return false
  return val > Date.now()
}

/** Smart-ish parser for freeform "When" */
function parseSmartWhen(s){
  if(!s) return null;

  let d = new Date(s);
  if(!Number.isNaN(d.getTime())) return d;

  const monthRx = /(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Sept|Oct|Nov|Dec)[a-z]*/i;
  const dayRx   = /\b([0-2]?\d|3[01])\b/;
  const timeRx  = /(\d{1,2}(?::\d{2})?)(?:\s*([ap]m))?/i;

  const monthMatch = s.match(monthRx);
  const dayMatch   = s.match(dayRx);
  const timeMatch  = s.match(timeRx);

  if(monthMatch && dayMatch){
    const month = monthMatch[0];
    const day   = dayMatch[1];
    const year  = new Date().getFullYear();

    let timeStr = "00:00";
    let ampmStr = null;

    if(timeMatch){
      const raw  = timeMatch[1];
      ampmStr    = timeMatch[2] || null;
      const [hh, mm = "00"] = raw.includes(":") ? raw.split(":") : [raw, "00"];

      const hNum      = parseInt(hh, 10);
      const assumePM  = !ampmStr && hNum >= 1 && hNum <= 8;
      timeStr         = `${hh}:${mm}`;

      d = new Date(`${month} ${day}, ${year} ${timeStr} ${assumePM ? "PM" : (ampmStr ? ampmStr.toUpperCase() : "")}`.trim());
    } else {
      d = new Date(`${month} ${day}, ${year} 00:00`);
    }

    if(!Number.isNaN(d.getTime())){
      const now = new Date();
      const tenMonthsMs = 1000*60*60*24*30*10;
      if(d.getTime() + tenMonthsMs < now.getTime()){
        d = new Date(`${month} ${day}, ${year+1} ${timeStr} ${ampmStr ? ampmStr.toUpperCase() : ''}`.trim());
      }
      if(!Number.isNaN(d.getTime())) return d;
    }
  }
  return null;
}

/** Rolling 7-day window for headers */
function getRollingHeaderDays(){
  const out = []
  const now = new Date()
  for(let i=0;i<7;i++){
    const d = new Date(now)
    d.setDate(now.getDate()+i)
    const key = d.toLocaleDateString([], { weekday:'short' }).slice(0,3)
    const label = `${key} ${d.toLocaleDateString([], { month:'short', day:'numeric' })}`
    out.push({ key, label })
  }
  return out
}

/** ---------- availability helpers ---------- */
function getWeeklyHours(email, role){
  const all = readAvail()
  const mine = all.filter(a => a.userEmail === email && a.role === role)
  const map = {}
  for (const d of DAYS){
    map[d] = mine.find(m=>m.day===d)?.hours || ''
  }
  return map
}

/** ---------- reminders (simple) ---------- */
function pushReminder(title, body){
  try{
    if (!('Notification' in window)) { alert(body); return }
    if (Notification.permission === 'granted'){
      new Notification(title, { body })
    } else if (Notification.permission !== 'denied'){
      Notification.requestPermission().then(perm=>{
        if (perm === 'granted') new Notification(title, { body })
        else alert(body)
      })
    } else {
      alert(body)
    }
  }catch{
    alert(body)
  }
}
function nextShift(email, role){
  const week = getWeeklyHours(email, role)
  const rolling = getRollingHeaderDays()
  for (const d of rolling){
    const hours = (week[d.key]||'').trim()
    if (hours && hours.toLowerCase()!=='off'){
      return `${d.label}, ${hours}`
    }
  }
  return null
}

/** ---------- UI helpers ---------- */
const cellCenter = {
  padding: "6px 8px",
  textAlign: "center",
  verticalAlign: "middle",
  fontSize: "11px"
};
const inputCenter = {
  width: "100%",
  padding: "6px 8px",
  border: "1px solid var(--border)",
  borderRadius: 8,
  outline: "none",
  background: "var(--card)",
  color: "var(--text)",
  fontWeight: 600,
  textAlign: "center",
};
const quiet = { fontSize: 11, color: 'var(--muted)' }
const quietMono = { ...quiet, fontFamily: 'ui-monospace, SFMono-Regular, Menlo, monospace' }
const badge = (tone="gray") => ({
  display: "inline-block",
  padding: "2px 8px",
  borderRadius: 999,
  fontSize: 12,
  fontWeight: 700,
  background: tone==="green" ? "var(--ok-bg)" : tone==="amber" ? "var(--warn-bg)" : "var(--muted-bg)",
  color: tone==="green" ? "var(--ok-fg)" : tone==="amber" ? "var(--warn-fg)" : "var(--muted)",
});

/** =======================================================================
 *  AdminAssign
 *  ======================================================================= */
export default function AdminAssign(){
  const [sales, setSales] = useState(readSales())
  const [assignments, setAssignments] = useState(readAssignments())
  const [neigh, setNeigh] = useState(readNeighborhoods())
  const [finishes, setFinishes] = useState(readJobFinishes())
  const [users, setUsers] = useState(readUsers())

  const [editUnassigned, setEditUnassigned] = useState(false)
  const [editSalesmanSnap, setEditSalesmanSnap] = useState(false)
  const [editWorkerSnap, setEditWorkerSnap] = useState(false)

  const [addCustomer, setAddCustomer] = useState({
    name: "",
    sellerEmail: "",
    phone: "",
    address: "",
    price: "",
    notes: ""
  })

  const [addWorker, setAddWorker] = useState({
    name: "",
    email: ""
  })

  const workers  = useMemo(
    () => users.filter(u =>
      u.role === 'worker' ||
      u.role === 'hybrid' ||
      u.role === 'admin'
    ),
    [users]
  )
  const salesmen = useMemo(
    () => users.filter(u =>
      u.role === 'seller' ||
      u.role === 'hybrid' ||
      u.role === 'admin'
    ),
    [users]
  )

  useEffect(()=>{
    setSales(readSales())
    setAssignments(readAssignments())
    setNeigh(readNeighborhoods())
    setFinishes(readJobFinishes())
  },[])

  useEffect(()=>{
    if (!hasSupa) return;
    (async ()=>{
      try{
        const [s,a,n,f,u] = await Promise.all([
          supa.from('sales').select('*').order('created_at', { ascending:false }),
          supa.from('assignments').select('*').order('created_at', { ascending:false }),
          supa.from('neighborhood_assignments').select('*').order('assigned_at', { ascending:false }),
          supa.from('job_finishes').select('*').order('finished_at', { ascending:false }),
          supa.from('users').select('*')
        ]);
        if(!s.error) setSales(s.data||[]);
        if(!a.error) setAssignments(a.data||[]);
        if(!n.error) setNeigh(n.data||[]);
        if(!f.error) setFinishes(f.data||[]);
        if(!u.error && Array.isArray(u.data)){
          setUsers(u.data);
          localStorage.setItem('users_seed', JSON.stringify(u.data));
        }
      }catch(_e){}
    })();
  },[])

  useEffect(()=>{
    function onStorage(e){
      if(e.key === 'jobFinishes'){
        setFinishes(readJobFinishes())
      }
    }
    window.addEventListener('storage', onStorage)
    const t = setInterval(()=> setFinishes(readJobFinishes()), 15000)
    return ()=>{ window.removeEventListener('storage', onStorage); clearInterval(t) }
  },[])

  const unassigned = useMemo(
    () => sales.filter(s => s.status === 'unassigned' || !s.status),
    [sales]
  )

  const [form, setForm] = useState({
    saleId: '',
    worker1: '',
    worker2: '',
    when: ''
  })

  const doAssign = async ()=>{
    if (!form.saleId || !form.worker1 || !form.worker2){
      alert('Pick a customer and two workers.'); return
    }
    const allSales = readSales()
    const idx = allSales.findIndex(s => String(s.id) === String(form.saleId))
    if (idx === -1){ alert('Customer not found.'); return }

    const w1 = users.find(u=>u.email===form.worker1)
    const w2 = users.find(u=>u.email===form.worker2)

    allSales[idx] = {
      ...allSales[idx],
      status: 'assigned',
      assignedTo: `${w1?.name||form.worker1} & ${w2?.name||form.worker2}`,
      when: form.when || ''
    }
    writeSales(allSales)
    setSales(allSales)

    const nextA = [
      ...readAssignments(),
      {
        id: Date.now(),
        saleId: form.saleId,
        workerEmail: form.worker1,
        worker2Email: form.worker2,
        when: form.when || '',
        status: 'assigned',
        createdAt: Date.now()
      }
    ]
    writeAssignments(nextA)
    setAssignments(nextA)

    try{
      if (hasSupa){
        const saleRow = allSales[idx];
        await supa.from('sales')
          .update({
            status: 'assigned',
            assigned_to: `${w1?.name||form.worker1} & ${w2?.name||form.worker2}`,
            when: form.when || null
          })
          .eq('id', saleRow.id);
        const newA = nextA[nextA.length-1];
        await supa.from('assignments').upsert({
          id: newA.id,
          sale_id: newA.saleId,
          worker_email: newA.workerEmail,
          worker2_email: newA.worker2Email,
          when: newA.when || null,
          status: newA.status,
          created_at: new Date().toISOString()
        });
      }
    }catch(_e){}

    setForm({ saleId:'', worker1:'', worker2:'', when:'' })
    alert('Assigned.')
  }

  const doOffer = async ()=>{
    if (!form.saleId || !form.worker1 || !form.worker2){
      alert('Pick a customer and two workers.'); return
    }
    const allSales = readSales()
    const idx = allSales.findIndex(s => String(s.id) === String(form.saleId))
    if (idx === -1){ alert('Customer not found.'); return }

    allSales[idx] = {
      ...allSales[idx],
      status: 'offered',
      assignedTo: undefined,
      when: form.when || ''
    }
    writeSales(allSales)
    setSales(allSales)

    const nextA = [
      ...readAssignments(),
      {
        id: Date.now(),
        saleId: form.saleId,
        workerEmail: form.worker1,
        worker2Email: form.worker2,
        when: form.when || '',
        status: 'offered',
        offeredTo: [form.worker1, form.worker2],
        createdAt: Date.now()
      }
    ]
    writeAssignments(nextA)
    setAssignments(nextA)

    try{
      if (hasSupa){
        const saleRow = allSales[idx];
        await supa.from('sales')
          .update({ status:'offered', when: form.when || null })
          .eq('id', saleRow.id);
        const newA = nextA[nextA.length-1];
        await supa.from('assignments').upsert({
          id: newA.id,
          sale_id: newA.saleId,
          worker_email: newA.workerEmail,
          worker2_email: newA.worker2Email,
          when: newA.when || null,
          status: newA.status,
          offered_to: newA.offeredTo || [],
          created_at: new Date().toISOString()
        });
      }
    }catch(_e){}

    setForm({ saleId:'', worker1:'', worker2:'', when:'' })
    alert('Offered to selected workers.')
  }

  const salesmanSnapshot = useMemo(()=>{
    return salesmen.map(sman=>{
      const mine = sales.filter(x=>x.sellerEmail===sman.email)
      const names = mine.map(x=>x.name).filter(Boolean)
      return {
        ...sman,
        weekHours: getWeeklyHours(sman.email, 'seller'),
        soldCount: mine.length,
        soldNames: names
      }
    })
  }, [salesmen, sales])

  const workerSnapshot = useMemo(()=>{
    return workers.map(w=>{
      const now = new Date();
      const myA = assignments.filter(a=>{
        const d = parseSmartWhen(a.when);
        return (a.workerEmail===w.email || a.worker2Email===w.email) && (!d || d >= now);
      });
      const customers = myA.map(a=>{
        const sale = sales.find(s=>String(s.id)===String(a.saleId))
        return sale?.name || '(customer)'
      }).filter(Boolean)
      const whens = myA.map(a=>a.when).filter(Boolean)
      return {
        ...w,
        isScheduled: myA.some(a=>a.status==='assigned') ? 'Yes' : 'No',
        customers, whens,
        weekHours: getWeeklyHours(w.email, 'worker')
      }
    })
  }, [workers, assignments, sales])

  const todayLabel = new Date().toLocaleDateString([], {
    weekday:'long', month:'short', day:'numeric', year:'numeric'
  })

  const [hoodSeller,setHoodSeller] = useState("")
  const [hoodName,setHoodName] = useState("")
  const [hoodDay,setHoodDay] = useState("")
  const [hoodNotes,setHoodNotes] = useState("")

  async function addNeighborhood(){
    if(!hoodSeller || !hoodName){
      alert("need seller + neighborhood name");
      return;
    }
    const sellerUser = users.find(u=>u.email===hoodSeller);
    const newRow = {
      id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
      sellerEmail: hoodSeller,
      sellerName: sellerUser?.name || hoodSeller,
      neighborhood: hoodName,
      day: hoodDay,
      notes: hoodNotes,
      assignedAt: Date.now()
    };
    const next = [...readNeighborhoods(), newRow];
    writeNeighborhoods(next);
    setNeigh(next);

    try{
      if (hasSupa){
        await supa.from('neighborhood_assignments').upsert({
          id: newRow.id,
          seller_email: newRow.sellerEmail,
          seller_name: newRow.sellerName,
          neighborhood: newRow.neighborhood,
          day: newRow.day || null,
          notes: newRow.notes || null,
          assigned_at: new Date().toISOString()
        });
      }
    }catch(_e){}

    setHoodSeller("");
    setHoodName("");
    setHoodDay("");
    setHoodNotes("");
  }

  const unifiedAll = useMemo(()=>{
    const jobs = assignments
      .filter(a=>a.status==='assigned')
      .map(a=>{
        const s = sales.find(x=> String(x.id)===String(a.saleId))
        const whenStr = a.when || "-"
        return {
          kind: "JOB",
          id: a.id,
          saleId: s?.id,
          when: whenStr,
          whenDate: parseSmartWhen(whenStr),
          salesmanEmail: s?.sellerEmail || "",
          salesmanName:  s?.sellerName  || s?.sellerEmail || "-",
          street: s?.address || "",
          notes:  s?.notes || "",
          customerName: s?.name || "",
          price: s?.price ?? null,
          paidFlag: s?.paid ?? undefined,
        }
      })

    const routes = (neigh||[]).map(n=>{
      const whenStr = n.day || "-"
      return {
        kind: "ROUTE",
        id: n.id,
        when: whenStr,
        whenDate: parseSmartWhen(whenStr),
        salesmanEmail: n.sellerEmail || "",
        salesmanName:  n.sellerName  || n.sellerEmail || "-",
        street: n.neighborhood || "",
        notes:  n.notes || "",
      }
    })

    return [...jobs, ...routes]
  }, [assignments, sales, neigh])

  const nowTs = Date.now()
  const futureUnified = useMemo(()=>{
    return unifiedAll
      .filter(r=>{
        if(r.whenDate) return r.whenDate.getTime() >= nowTs
        return true
      })
      .sort((a,b)=>{
        const at = a.whenDate ? a.whenDate.getTime() : Infinity
        const bt = b.whenDate ? b.whenDate.getTime() : Infinity
        return at - bt
      })
  }, [unifiedAll, nowTs])

  const pastUnified = useMemo(()=>{
    return unifiedAll
      .filter(r=> r.whenDate && r.whenDate.getTime() < nowTs)
      .sort((a,b)=> b.whenDate.getTime() - a.whenDate.getTime())
  }, [unifiedAll, nowTs])

  const [editFuture, setEditFuture] = useState(false)
  const [editPast, setEditPast] = useState(false)

  function eToPaidLabel(p){ return p ? 'Paid' : 'Unpaid' }

  function upsertFinish(assignmentId, patch){
    const list = readJobFinishes()
    const i = list.findIndex(f => String(f.assignmentId) === String(assignmentId))
    if(i >= 0){
      list[i] = { ...list[i], ...patch }
    } else {
      list.push({
        assignmentId,
        finishedAt: new Date().toISOString(),
        worked: true,
        ...patch
      })
    }
    localStorage.setItem('jobFinishes', JSON.stringify(list))
    setFinishes(list)
  }

  function patchUnified(row, field, value){
    if(row.kind === "JOB"){
      if(field === "when"){
        const nextA = readAssignments().map(a => a.id===row.id ? {...a, when:value} : a)
        writeAssignments(nextA); setAssignments(nextA)
        ;(async()=>{try{ if(hasSupa){ await supa.from('assignments').update({ when: value||null }).eq('id', row.id); }}catch(_e){}})();
      } else if(field === "salesman"){
        const nextS = readSales().map(s=>{
          if(String(s.id)!==String(row.saleId)) return s
          const u = users.find(x=>x.email===value)
          return {...s, sellerEmail:value, sellerName:u?.name||value}
        })
        writeSales(nextS); setSales(nextS)
        ;(async()=>{try{ if(hasSupa){ await supa.from('sales').update({ seller_email: value }).eq('id', row.saleId); }}catch(_e){}})();
      } else if(field === "street"){
        const nextS = readSales().map(s => String(s.id)===String(row.saleId) ? {...s, address:value} : s)
        writeSales(nextS); setSales(nextS)
        ;(async()=>{try{ if(hasSupa){ await supa.from('sales').update({ address: value }).eq('id', row.saleId); }}catch(_e){}})();
      } else if(field === "notes"){
        const nextS = readSales().map(s => String(s.id)===String(row.saleId) ? {...s, notes:value} : s)
        writeSales(nextS); setSales(nextS)
        ;(async()=>{try{ if(hasSupa){ await supa.from('sales').update({ notes: value||null }).eq('id', row.saleId); }}catch(_e){}})();
      }
    } else {
      if(field === "when"){
        const nextN = readNeighborhoods().map(n => n.id===row.id ? {...n, day:value} : n)
        writeNeighborhoods(nextN); setNeigh(nextN)
        ;(async()=>{try{ if(hasSupa){ await supa.from('neighborhood_assignments').update({ day: value||null }).eq('id', row.id); }}catch(_e){}})();
      } else if(field === "salesman"){
        const nextN = readNeighborhoods().map(n=>{
          if(n.id!==row.id) return n
          const u = users.find(x=>x.email===value)
          return {...n, sellerEmail:value, sellerName:u?.name||value}
        })
        writeNeighborhoods(nextN); setNeigh(nextN)
        ;(async(()=>{try{ if(hasSupa){ await supa.from('neighborhood_assignments').update({ seller_email: value }).eq('id', row.id); }}catch(_e){}}))();
      } else if(field === "street"){
        const nextN = readNeighborhoods().map(n => n.id===row.id ? {...n, neighborhood:value} : n)
        writeNeighborhoods(nextN); setNeigh(nextN)
        ;(async()=>{try{ if(hasSupa){ await supa.from('neighborhood_assignments').update({ neighborhood: value }).eq('id', row.id); }}catch(_e){}})();
      } else if(field === "notes"){
        const nextN = readNeighborhoods().map(n => n.id===row.id ? {...n, notes:value} : n)
        writeNeighborhoods(nextN); setNeigh(nextN)
        ;(async()=>{try{ if(hasSupa){ await supa.from('neighborhood_assignments').update({ notes: value||null }).eq('id', row.id); }}catch(_e){}})();
      }
    }
  }

  function deleteUnified(row){
    if(row.kind === "JOB"){
      const nextA = readAssignments().filter(a => a.id !== row.id)
      writeAssignments(nextA); setAssignments(nextA)
      ;(async()=>{try{ if(hasSupa){ await supa.from('assignments').delete().eq('id', row.id); }}catch(_e){}})();
    } else {
      const nextN = readNeighborhoods().filter(n => n.id !== row.id)
      writeNeighborhoods(nextN); setNeigh(nextN)
      ;(async(()=>{try{ if(hasSupa){ await supa.from('neighborhood_assignments').delete().eq('id', row.id); }}catch(_e){}}))();
    }
  }

  useEffect(()=>{
    const t = setInterval(()=> setAssignments(a => a), 45000)
    return ()=> clearInterval(t)
  },[])

  function startOfDay(ts){
    const d = new Date(ts); d.setHours(0,0,0,0); return d.getTime()
  }
  function endOfDay(ts){
    const d = new Date(ts); d.setHours(23,59,59,999); return d.getTime()
  }
  function soldForRow(row){
    if(row.kind === 'JOB'){
      const name = row.customerName || '(customer)'
      return { count: name ? 1 : 0, names: name ? [name] : [] }
    }
    if(row.kind === 'ROUTE' && row.whenDate){
      const dayStart = startOfDay(row.whenDate)
      const dayEnd   = endOfDay(row.whenDate)
      const todaysSales = readSales().filter(s =>
        s.sellerEmail === row.salesmanEmail &&
        s.createdAt &&
        Number(new Date(s.createdAt).getTime()) >= dayStart &&
        Number(new Date(s.createdAt).getTime()) <= dayEnd
      )
      const names = todaysSales.map(s => s.name).filter(Boolean)
      return { count: names.length, names }
    }
    return { count: 0, names: [] }
  }

  return (
    <div className="grid" style={{ marginTop: -52 }}>
      <div className="card">
        <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', gap:8}}>
          <h2 className="section-title">Unassigned Customers</h2>
          <button className="btn outline" onClick={()=>{
            setEditUnassigned(v=>!v)
            if(editUnassigned){
              setSales(readSales())
            }
          }}>
            {editUnassigned ? "Done" : "Edit"}
          </button>
        </div>

        <table className="table">
          <thead>
            <tr>
              <th style={cellCenter}>Customer</th>
              <th style={cellCenter}>Salesman</th>
              <th style={cellCenter}>Phone</th>
              <th style={cellCenter}>Address</th>
              <th style={cellCenter}>Price</th>
              <th style={cellCenter}>Notes</th>
              <th style={cellCenter}>Date</th>
              {editUnassigned && <th style={cellCenter}></th>}
            </tr>
          </thead>
          <tbody>
            {unassigned.length===0 && (
              <tr><td colSpan={editUnassigned?8:7} style={{...cellCenter, color:'#64748b'}}>No unassigned customers.</td></tr>
            )}
            {unassigned.map(s=>(
      <tr key={s.id}>
        <td style={cellCenter}>{s.name}</td>
        <td style={cellCenter}>{s.sellerName} ({s.sellerEmail})</td>
        <td style={cellCenter}>{s.phone}</td>
        <td style={cellCenter}>{s.address}</td>
        <td style={cellCenter}>{s.price ? `$${s.price}` : '-'}</td>
        <td style={cellCenter}>{s.notes || '-'}</td>
        <td style={cellCenter}>{fmtDateOnly(s.createdAt)}</td>
        {editUnassigned && (
          <td style={cellCenter}>
            <button
              className="btn outline"
              style={{fontSize:11, padding:"4px 6px", lineHeight:1, color:"var(--accent)", marginRight:4}}
              onClick={()=>{
                if(window.confirm("Are you sure?")){
                  const next = readSales().filter(x=>String(x.id)!==String(s.id))
                  writeSales(next)
                  setSales(next)
                }
              }}
            >
              Delete
            </button>
            <button
              className="btn outline"
              style={{fontSize:11, padding:"4px 6px", lineHeight:1, color:"var(--danger)"}}
              onClick={()=>{
                if(window.confirm("Permanently delete this customer row? This cannot be undone.")){
                  const next = readSales().filter(x=>String(x.id)!==String(s.id))
                  writeSales(next)
                  setSales(next)
                }
              }}
            >
              Delete Row
            </button>
          </td>
        )}
      </tr>
            ))}
            {editUnassigned && (
              <tr>
                <td style={cellCenter}>
                  <input
                    value={addCustomer.name}
                    onChange={e=>setAddCustomer({...addCustomer, name:e.target.value})}
                    style={inputCenter}
                    placeholder="Name"
                  />
                </td>
                <td style={cellCenter}>
                  <select
                    value={addCustomer.sellerEmail}
                    onChange={e=>setAddCustomer({...addCustomer, sellerEmail:e.target.value})}
                    style={inputCenter}
                  >
                    <option value="">—</option>
                    {users.filter(u=>u.role==='seller'||u.role==='hybrid'||u.role==='admin').map(u=>(
                      <option key={u.email} value={u.email}>{u.name||u.email}</option>
                    ))}
                  </select>
                </td>
                <td style={cellCenter}>
                  <input
                    value={addCustomer.phone}
                    onChange={e=>setAddCustomer({...addCustomer, phone:e.target.value})}
                    style={inputCenter}
                    placeholder="Phone"
                  />
                </td>
                <td style={cellCenter}>
                  <input
                    value={addCustomer.address}
                    onChange={e=>setAddCustomer({...addCustomer, address:e.target.value})}
                    style={inputCenter}
                    placeholder="Address"
                  />
                </td>
                <td style={cellCenter}>
                  <input
                    type="number"
                    value={addCustomer.price}
                    onChange={e=>setAddCustomer({...addCustomer, price:e.target.value})}
                    style={inputCenter}
                    placeholder="Price"
                  />
                </td>
                <td style={cellCenter}>
                  <input
                    value={addCustomer.notes}
                    onChange={e=>setAddCustomer({...addCustomer, notes:e.target.value})}
                    style={inputCenter}
                    placeholder="Notes"
                  />
                </td>
                <td style={cellCenter}>—</td>
                <td style={cellCenter}>
                  <button
                    className="btn outline"
                    onClick={()=>{
                      if(!addCustomer.name || !addCustomer.sellerEmail){
                        alert("Name and Salesman required"); return;
                      }
                      const sellerUser = users.find(u=>u.email===addCustomer.sellerEmail);
                      const newRec = {
                        id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
                        name: addCustomer.name,
                        sellerEmail: addCustomer.sellerEmail,
                        sellerName: sellerUser?.name || addCustomer.sellerEmail,
                        phone: addCustomer.phone,
                        address: addCustomer.address,
                        price: addCustomer.price,
                        notes: addCustomer.notes,
                        status: "unassigned",
                        createdAt: Date.now()
                      };
                      const next = [...readSales(), newRec];
                      writeSales(next);
                      setSales(next);

                      (async ()=>{ try{
                        if (hasSupa){
                          await supa.from('sales').upsert({
                            id: newRec.id,
                            name: newRec.name,
                            seller_email: newRec.sellerEmail,
                            seller_name: newRec.sellerName,
                            phone: newRec.phone || null,
                            address: newRec.address || null,
                            price: newRec.price ? Number(newRec.price) : null,
                            notes: newRec.notes || null,
                            status: newRec.status || 'unassigned',
                            created_at: new Date().toISOString()
                          });
                        }
                      }catch(_e){} })();

                      setAddCustomer({ name: "", sellerEmail: "", phone: "", address: "", price: "", notes: "" });
                    }}
                  >
                    Add Customer
                  </button>
                </td>
              </tr>
            )}
          </tbody>
        </table>

        <div className="grid" style={{marginTop:-50}}>
          <div className="row">
            <div style={{flex:2}}>
              <label>Select Customer</label>
              <select
                value={form.saleId}
                onChange={e=>setForm({...form, saleId:e.target.value})}
                style={inputCenter}
              >
                <option value="">—</option>
                {unassigned.map(s=>(
                  <option key={s.id} value={s.id}>
                    {s.name} • {s.address}
                  </option>
                ))}
              </select>
            </div>

            <div style={{flex:2}}>
              <label>Worker 1</label>
              <select
                value={form.worker1}
                onChange={e=>setForm({...form, worker1:e.target.value})}
                style={inputCenter}
              >
                <option value="">—</option>
                {users.filter(w=>w.role==='worker'||w.role==='hybrid'||w.role==='admin').map(w=>(
                  <option key={w.email} value={w.email}>
                    {w.name || w.email}
                  </option>
                ))}
              </select>
            </div>

            <div style={{flex:2}}>
              <label>Worker 2</label>
              <select
                value={form.worker2}
                onChange={e=>setForm({...form, worker2:e.target.value})}
                style={inputCenter}
              >
                <option value="">—</option>
                {users.filter(w=>w.role==='worker'||w.role==='hybrid'||w.role==='admin').map(w=>(
                  <option key={w.email} value={w.email}>
                    {w.name || w.email}
                  </option>
                ))}
              </select>
            </div>

            <div style={{flex:2}}>
              <label>Date &amp; Time</label>
              <input
                value={form.when}
                onChange={e=>setForm({...form, when:e.target.value})}
                placeholder="2025-11-07T16:00 (ISO preferred) or 'Nov 1 / 1:20-3'"
                style={inputCenter}
              />
            </div>
          </div>

          <div className="toolbar" style={{display:'flex', gap:8, justifyContent:'center'}}>
            <button className="btn" onClick={doAssign}>Assign</button>
            <button className="btn outline" onClick={doOffer}>Offer to Workers</button>
          </div>
        </div>
      </div>

      <div className="card">
        <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', gap:8}}>
          <h2 className="section-title">Salesman Snapshot</h2>
          <button className="btn outline" onClick={()=>{
            setEditSalesmanSnap(v=>!v)
            if(editSalesmanSnap){
              setSales(readSales())
              setAssignments(readAssignments())
              setNeigh(readNeighborhoods())
            }
          }}>
            {editSalesmanSnap ? "Done" : "Edit"}
          </button>
        </div>
        <table className="table">
          <thead>
            <tr>
              <th style={cellCenter}>Salesman</th>
              <th style={cellCenter}>Customers sold this week (names)</th>
              {getRollingHeaderDays().map(d => <th key={d.label} style={cellCenter}>{d.label}</th>)}
              <th style={cellCenter}>Remind</th>
            </tr>
          </thead>
          <tbody>
            {salesmanSnapshot.length===0 && (
              <tr><td colSpan={11} style={{...cellCenter, color:'#64748b'}}>No salesmen.</td></tr>
            )}
            {salesmanSnapshot.map(s=>(
              <tr key={s.email}>
                {editSalesmanSnap ? (
                  <>
                    <td style={cellCenter}>
                      <input
                        type="text"
                        value={(() => {
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===s.email)
                          if(idx>=0 && typeof allUsers[idx].name === 'string') {
                            return allUsers[idx].name
                          }
                          return s.name || ''
                        })()}
                        style={inputCenter}
                        placeholder="Salesman Name"
                    onChange={e=>{
                      const val = e.target.value
                      const allUsers = readUsers()
                      const idx = allUsers.findIndex(u=>u.email===s.email)
                      if(idx>=0){
                        let user = {...allUsers[idx]}
                        user.name = val
                        allUsers[idx] = user
                        localStorage.setItem('users_seed', JSON.stringify(allUsers))
                        setSales(readSales())
                        setAssignments(readAssignments())
                      }
                    }}
                      />
                    </td>
                    <td style={cellCenter}>
                      <input
                        type="text"
                        value={(() => {
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===s.email)
                          if(idx>=0 && allUsers[idx].salesmanSnapshot && typeof allUsers[idx].salesmanSnapshot.soldNames === 'string') {
                            return allUsers[idx].salesmanSnapshot.soldNames
                          }
                          return s.soldNames?.join(', ') || ''
                        })()}
                        style={inputCenter}
                        placeholder="Names, comma-separated"
                    onChange={e=>{
                      const val = e.target.value
                      const allUsers = readUsers()
                      const idx = allUsers.findIndex(u=>u.email===s.email)
                      if(idx>=0){
                        let user = {...allUsers[idx]}
                        user.salesmanSnapshot = {...(user.salesmanSnapshot||{}), soldNames: val}
                        allUsers[idx] = user
                        localStorage.setItem('users_seed', JSON.stringify(allUsers))
                        setSales(readSales())
                        setAssignments(readAssignments())
                      }
                    }}
                      />
                      <input
                        type="number"
                        value={(() => {
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===s.email)
                          if(idx>=0 && allUsers[idx].salesmanSnapshot && typeof allUsers[idx].salesmanSnapshot.soldCount !== 'undefined') {
                            return allUsers[idx].salesmanSnapshot.soldCount
                          }
                          return s.soldCount || 0
                        })()}
                        min={0}
                        style={{...inputCenter, marginTop: 4}}
                    onChange={e=>{
                      const val = parseInt(e.target.value,10)
                      const allUsers = readUsers()
                      const idx = allUsers.findIndex(u=>u.email===s.email)
                      if(idx>=0){
                        let user = {...allUsers[idx]}
                        user.salesmanSnapshot = {...(user.salesmanSnapshot||{}), soldCount: val}
                        allUsers[idx] = user
                        localStorage.setItem('users_seed', JSON.stringify(allUsers))
                        setSales(readSales())
                        setAssignments(readAssignments())
                      }
                    }}
                        placeholder="Sold count"
                      />
                    </td>
                    {getRollingHeaderDays().map(d=>(
                      <td key={d.label} style={{...cellCenter, fontSize:12}}>
                        <input
                          value={s.weekHours[d.key]||""}
                          onChange={e=>{
                            const avail = readAvail()
                            const idx = avail.findIndex(a=>a.userEmail===s.email && a.role==='seller' && a.day===d.key)
                            let nextAvail
                            if(idx>=0){
                              nextAvail = [...avail]
                              nextAvail[idx] = {...nextAvail[idx], hours:e.target.value}
                            } else {
                              nextAvail = [...avail, {userEmail:s.email, role:'seller', day:d.key, hours:e.target.value}]
                            }
                            localStorage.setItem('availability', JSON.stringify(nextAvail))
                            setSales(readSales())
                            setAssignments(readAssignments())
                          }}
                          style={inputCenter}
                          placeholder="Hours"
                        />
                      </td>
                    ))}
                    <td style={cellCenter}>
                      <button
                        className="btn outline"
                        onClick={()=>{
                          const nxt = nextShift(s.email,'seller')
                          pushReminder(
                            'Next Shift',
                            nxt ? `${s.name} — ${nxt}` : `${s.name}: no upcoming hours found.`
                          )
                        }}
                      >
                        Remind
                      </button>
                    </td>
                  </>
                ) : (
                  <>
                    <td style={cellCenter}>{s.name}</td>
                    <td style={cellCenter}>
                      {(() => {
                        const allUsers = readUsers()
                        const idx = allUsers.findIndex(u=>u.email===s.email)
                        let soldNames = null
                        if(idx>=0 && allUsers[idx].salesmanSnapshot && typeof allUsers[idx].salesmanSnapshot.soldNames === 'string') {
                          soldNames = allUsers[idx].salesmanSnapshot.soldNames
                        }
                        const showNames = soldNames || (s.soldNames?.join(', ') || '')
                        return (
                          <>
                            {(() => {
                              if(idx>=0 && allUsers[idx].salesmanSnapshot && typeof allUsers[idx].salesmanSnapshot.soldCount !== 'undefined') {
                                return allUsers[idx].salesmanSnapshot.soldCount
                              }
                              return s.soldCount || 0
                            })()}
                            {showNames && (
                              <div style={quiet}>
                                {showNames}
                              </div>
                            )}
                          </>
                        )
                      })()}
                    </td>
                    {getRollingHeaderDays().map(d=>(
                      <td key={d.label} style={{...cellCenter, fontSize:12}}>
                        {s.weekHours[d.key]||'-'}
                      </td>
                    ))}
                    <td style={cellCenter}>
                      <button
                        className="btn outline"
                        onClick={()=>{
                          const nxt = nextShift(s.email,'seller')
                          pushReminder(
                            'Next Shift',
                            nxt ? `${s.name} — ${nxt}` : `${s.name}: no upcoming hours found.`
                          )
                        }}
                      >
                        Remind
                      </button>
                    </td>
                  </>
                )}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <div className="card">
        <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', gap:8}}>
          <h2 className="section-title">Worker Snapshot</h2>
          <button className="btn outline" onClick={()=>{
            setEditWorkerSnap(v=>!v)
            if(editWorkerSnap){
              setAssignments(readAssignments())
              setSales(readSales())
            }
          }}>
            {editWorkerSnap ? "Done" : "Edit"}
          </button>
        </div>
        <table className="table">
          <thead>
            <tr>
              <th style={cellCenter}>Worker</th>
              <th style={cellCenter}>Scheduled?</th>
              <th style={cellCenter}>Customer(s)</th>
              <th style={cellCenter}>When (time &amp; date)</th>
              {getRollingHeaderDays().map(d => <th key={d.label} style={cellCenter}>{d.label}</th>)}
              <th style={cellCenter}>Remind</th>
            </tr>
          </thead>
          <tbody>
            {workerSnapshot.length===0 && (
              <tr><td colSpan={13} style={{...cellCenter, color:'#64748b'}}>No workers.</td></tr>
            )}
            {workerSnapshot.map(w=>(
              <tr key={w.email}>
                {editWorkerSnap ? (
                  <>
                    <td style={cellCenter}>
                      <input
                        type="text"
                        value={(() => {
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===w.email)
                          if(idx>=0 && typeof allUsers[idx].name === 'string') {
                            return allUsers[idx].name
                          }
                          return w.name || ''
                        })()}
                        style={inputCenter}
                        placeholder="Worker Name"
                        onChange={e=>{
                          const val = e.target.value
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===w.email)
                          if(idx>=0){
                            let user = {...allUsers[idx]}
                            user.name = val
                            allUsers[idx] = user
                            localStorage.setItem('users_seed', JSON.stringify(allUsers))
                            writeAssignments(readAssignments())
                            setAssignments(readAssignments())
                          }
                        }}
                      />
                    </td>
                    <td style={cellCenter}>
                      <input
                        type="text"
                        value={(() => {
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===w.email)
                          if(idx>=0 && typeof allUsers[idx].workerSnapshot === 'object' && typeof allUsers[idx].workerSnapshot.isScheduled === 'string') {
                            return allUsers[idx].workerSnapshot.isScheduled
                          }
                          return w.isScheduled || (w.customers?.length>0 ? 'Yes':'No')
                        })()}
                        style={inputCenter}
                        onChange={e=>{
                          const val = e.target.value
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===w.email)
                          if(idx>=0){
                            let user = {...allUsers[idx]}
                            user.workerSnapshot = {...(user.workerSnapshot||{}), isScheduled: val}
                            allUsers[idx] = user
                            localStorage.setItem('users_seed', JSON.stringify(allUsers))
                            writeAssignments(readAssignments())
                            setAssignments(readAssignments())
                          }
                        }}
                        placeholder="Scheduled?"
                      />
                    </td>
                    <td style={cellCenter}>
                      <input
                        type="text"
                        value={(() => {
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===w.email)
                          if(idx>=0 && allUsers[idx].workerSnapshot && typeof allUsers[idx].workerSnapshot.customers === 'string') {
                            return allUsers[idx].workerSnapshot.customers
                          }
                          return w.customers?.join(', ') || ''
                        })()}
                        style={inputCenter}
                        onChange={e=>{
                          const val = e.target.value
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===w.email)
                          if(idx>=0){
                            let user = {...allUsers[idx]}
                            user.workerSnapshot = {...(user.workerSnapshot||{}), customers: val}
                            allUsers[idx] = user
                            localStorage.setItem('users_seed', JSON.stringify(allUsers))
                            writeAssignments(readAssignments())
                            setAssignments(readAssignments())
                          }
                        }}
                        placeholder="Customers"
                      />
                    </td>
                    <td style={cellCenter}>
                      <input
                        type="text"
                        value={(() => {
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===w.email)
                          if(idx>=0 && allUsers[idx].workerSnapshot && typeof allUsers[idx].workerSnapshot.whens === 'string') {
                            return allUsers[idx].workerSnapshot.whens
                          }
                          return w.whens?.join(' • ') || ''
                        })()}
                        style={inputCenter}
                        onChange={e=>{
                          const val = e.target.value
                          const allUsers = readUsers()
                          const idx = allUsers.findIndex(u=>u.email===w.email)
                          if(idx>=0){
                            let user = {...allUsers[idx]}
                            user.workerSnapshot = {...(user.workerSnapshot||{}), whens: val}
                            allUsers[idx] = user
                            localStorage.setItem('users_seed', JSON.stringify(allUsers))
                            writeAssignments(readAssignments())
                            setAssignments(readAssignments())
                          }
                        }}
                        placeholder="When(s)"
                      />
                    </td>
                    {getRollingHeaderDays().map(d=>(
                      <td key={d.label} style={{...cellCenter, fontSize:12}}>
                        <input
                          value={w.weekHours[d.key]||""}
                        onChange={e=>{
                          const avail = readAvail()
                          const idx = avail.findIndex(a=>a.userEmail===w.email && a.role==='worker' && a.day===d.key)
                          let nextAvail
                          if(idx>=0){
                            nextAvail = [...avail]
                            nextAvail[idx] = {...nextAvail[idx], hours:e.target.value}
                          } else {
                            nextAvail = [...avail, {userEmail:w.email, role:'worker', day:d.key, hours:e.target.value}]
                          }
                          localStorage.setItem('availability', JSON.stringify(nextAvail))
                          writeAssignments(readAssignments())
                          setAssignments(readAssignments())
                        }}
                          style={inputCenter}
                          placeholder="Hours"
                        />
                      </td>
                    ))}
                    <td style={cellCenter}>
                      <button
                        className="btn outline"
                        onClick={()=>{
                          const nxt = nextShift(w.email,'worker')
                          pushReminder(
                            'Next Shift',
                            nxt ? `${w.name} — ${nxt}` : `${w.name}: no upcoming hours found.`
                          )
                        }}
                      >
                        Remind
                      </button>
                    </td>
                  </>
                ) : (
                  <>
                    <td style={cellCenter}>{w.name}</td>
                    <td style={cellCenter}>
                      <span style={badge(w.customers?.length>0 ? 'green' : 'amber')}>
                        {w.customers?.length>0 ? 'Yes':'No'}
                      </span>
                    </td>
                    <td style={cellCenter}>{w.customers?.length>0 ? w.customers.join(', ') : '-'}</td>
                    <td style={cellCenter}>{w.whens?.length>0 ? w.whens.join(' • ') : '-'}</td>
                    {getRollingHeaderDays().map(d=>(
                      <td key={d.label} style={{...cellCenter, fontSize:12}}>
                        {w.weekHours[d.key]||'-'}
                      </td>
                    ))}
                    <td style={cellCenter}>
                      <button
                        className="btn outline"
                        onClick={()=>{
                          const nxt = nextShift(w.email,'worker')
                          pushReminder(
                            'Next Shift',
                            nxt ? `${w.name} — ${nxt}` : `${w.name}: no upcoming hours found.`
                          )
                        }}
                      >
                        Remind
                      </button>
                    </td>
                  </>
                )}
              </tr>
            ))}
          </tbody>
        </table>
      </div>

      <div className="card" style={{marginTop:16}}>
        <h2 className="section-title">Assign Neighborhood</h2>

        <div style={{
          display:'grid',
          gridTemplateColumns:'repeat(auto-fit,minmax(200px,1fr))',
          gap:12
        }}>
          <div>
            <div style={{fontSize:12, fontWeight:600, marginBottom:4}}>Seller</div>
            <select
              style={inputCenter}
              value={hoodSeller}
              onChange={e=>setHoodSeller(e.target.value)}
            >
              <option value="">Choose seller…</option>
              {users
                .filter(u=>u.role==='seller' || u.role==='hybrid' || u.role==='admin')
                .map(u=>(
                  <option key={u.email} value={u.email}>{u.name}</option>
                ))}
            </select>
          </div>

          <div>
            <div style={{fontSize:12, fontWeight:600, marginBottom:4}}>
              Neighborhood / Route Name
            </div>
            <input
              style={inputCenter}
              placeholder="River Oaks / Spring Trails..."
              value={hoodName}
              onChange={e=>setHoodName(e.target.value)}
            />
          </div>

          <div>
            <div style={{fontSize:12, fontWeight:600, marginBottom:4}}>
              Day / Time Window
            </div>
            <input
              style={inputCenter}
              placeholder="2025-11-07T16:00 (ISO preferred) or 'Fri 4-7pm'"
              value={hoodDay}
              onChange={e=>setHoodDay(e.target.value)}
            />
          </div>

          <div>
            <div style={{fontSize:12, fontWeight:600, marginBottom:4}}>Notes</div>
            <input
              style={inputCenter}
              placeholder="Meet at Starbucks lot / HOA ok'd"
              value={hoodNotes}
              onChange={e=>setHoodNotes(e.target.value)}
            />
          </div>
        </div>

        <div style={{display:'flex', justifyContent:'center'}}>
          <button
            className="btn"
            style={{marginTop:12}}
            onClick={addNeighborhood}
          >
            Save Neighborhood
          </button>
        </div>
      </div>

      <div>
        <div className="card" style={{marginTop:16}}>
          <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', gap:8}}>
            <h2 className="section-title">Future Neighborhood</h2>
            <button className="btn outline" onClick={()=>{
              setEditFuture(v=>!v)
              if(editFuture){
                setNeigh(readNeighborhoods())
                setAssignments(readAssignments())
                setSales(readSales())
              }
            }}>
              {editFuture ? "Done" : "Edit"}
            </button>
          </div>
          <div style={editFuture ? {paddingRight: 120, transition: 'padding-right 0.2s'} : {}}>
            <table className="table" style={{fontSize:12}}>
              <thead>
                <tr>
                  <th style={cellCenter}>When / Day</th>
                  <th style={cellCenter}>Salesman</th>
                  <th style={cellCenter}>Street</th>
                  <th style={cellCenter}>Notes</th>
                  {editFuture && <th style={cellCenter}></th>}
                </tr>
              </thead>
              <tbody>
                {futureUnified.length===0 && (
                  <tr>
                    <td colSpan={editFuture?5:4} style={{...cellCenter, color:'var(--muted)'}}>
                      Nothing scheduled yet.
                    </td>
                  </tr>
                )}
                {futureUnified.map(row=>(
                  <tr key={`${row.kind}-${row.id}`}>
                    <td style={cellCenter}>
                      {editFuture
                        ? <input
                            value={row.when || ""}
                            onChange={(e)=>patchUnified(row, "when", e.target.value)}
                            placeholder="2025-11-07T16:00 or text"
                            style={inputCenter}
                          />
                        : (row.when || "-")}
                    </td>
                    <td style={cellCenter}>
                      {editFuture
                        ? (
                          <select
                            value={row.salesmanEmail || ""}
                            onChange={(e)=>patchUnified(row, "salesman", e.target.value)}
                            style={inputCenter}
                          >
                            <option value="">—</option>
                            {salesmen.map(u=>(
                              <option key={u.email} value={u.email}>{u.name||u.email}</option>
                            ))}
                          </select>
                        )
                        : (row.salesmanName || "-")}
                    </td>
                    <td style={cellCenter}>
                      {editFuture
                        ? <input
                            value={row.street || ""}
                            onChange={(e)=>patchUnified(row, "street", e.target.value)}
                            placeholder="123 Main St / Midtown"
                            style={inputCenter}
                          />
                        : (row.street || "-")}
                    </td>
                    <td style={cellCenter}>
                      {editFuture
                        ? <input
                            value={row.notes || ""}
                            onChange={(e)=>patchUnified(row, "notes", e.target.value)}
                            placeholder="Gate code 1234; meet at cul-de-sac"
                            style={inputCenter}
                          />
                        : (row.notes || "-")}
                    </td>
                    {editFuture && (
                      <td style={cellCenter}>
                        <button
                          className="btn outline"
                          style={{fontSize:11, padding:"4px 6px", lineHeight:1, color:"var(--accent)"}}
                          onClick={()=>{
                            if(window.confirm("Delete this row?")){
                              deleteUnified(row)
                            }
                          }}
                        >
                          Delete
                        </button>
                      </td>
                    )}
                  </tr>
                ))}
                {editFuture && (
                  <FutureAddRow
                    salesmen={salesmen}
                    onAdd={row => {
                      const next = [...readNeighborhoods(), row]
                      writeNeighborhoods(next)
                      setNeigh(next)
                      ;(async()=>{
                        try{
                          if (hasSupa){
                            await supa.from('neighborhood_assignments').upsert({
                              id: row.id,
                              seller_email: row.sellerEmail,
                              seller_name: row.sellerName,
                              neighborhood: row.neighborhood,
                              day: row.day || null,
                              notes: row.notes || null,
                              assigned_at: new Date().toISOString()
                            });
                          }
                        }catch(_e){}
                      })();
                    }}
                  />
                )}
              </tbody>
            </table>
          </div>
          <div style={{fontSize:12, color:'var(--muted)', marginTop:8, lineHeight:1.4, textAlign:'center'}}>
            Tip: Use an ISO datetime (e.g., <code>2025-11-07T16:00</code>) for <strong>When</strong> to guarantee correct future→past movement.
          </div>
        </div>
      </div>

      <div>
        <div className="card" style={{marginTop:16}}>
          <div style={{display:'flex', justifyContent:'space-between', alignItems:'center', gap:8}}>
            <h2 className="section-title">Past Neighborhood</h2>
            <button className="btn outline" onClick={()=>{
              setEditPast(v=>!v)
              if(editPast){
                setNeigh(readNeighborhoods())
                setAssignments(readAssignments())
                setSales(readSales())
              }
            }}>
              {editPast ? "Done" : "Edit"}
            </button>
          </div>
          <div style={editPast ? {paddingRight: 120, transition: 'padding-right 0.2s'} : {}}>
            <table className="table" style={{fontSize:12}}>
              <thead>
                <tr>
                  <th style={cellCenter}>When / Day</th>
                  <th style={cellCenter}>Salesman</th>
                  <th style={cellCenter}>Street</th>
                  <th style={cellCenter}>Notes</th>
                  <th style={cellCenter}>Customers Sold</th>
                  {editPast && <th style={cellCenter}></th>}
                </tr>
              </thead>
              <tbody>
                {pastUnified.length===0 && (
                  <tr>
                    <td colSpan={editPast?6:5} style={{...cellCenter, color:'var(--muted)'}}>
                      No past neighborhoods yet.
                    </td>
                  </tr>
                )}
                {pastUnified.map(row=>{
                  const sold = soldForRow(row)
                  return (
                    <tr key={`past-${row.kind}-${row.id}`}>
                      <td style={cellCenter}>
                        {editPast ? (
                          <input
                            value={row.when || ""}
                            onChange={(e)=>patchUnified(row, "when", e.target.value)}
                            placeholder="2025-11-07T16:00 or text"
                            style={inputCenter}
                          />
                        ) : (row.when || "-")}
                      </td>
                      <td style={cellCenter}>
                        {editPast ? (
                          <select
                            value={row.salesmanEmail || ""}
                            onChange={(e)=>patchUnified(row, "salesman", e.target.value)}
                            style={inputCenter}
                          >
                            <option value="">—</option>
                            {salesmen.map(u=>(
                              <option key={u.email} value={u.email}>{u.name||u.email}</option>
                            ))}
                          </select>
                        ) : (row.salesmanName || "-")}
                      </td>
                      <td style={cellCenter}>
                        {editPast ? (
                          <input
                            value={row.street || ""}
                            onChange={(e)=>patchUnified(row, "street", e.target.value)}
                            placeholder="123 Main St / Midtown"
                            style={inputCenter}
                          />
                        ) : (row.street || "-")}
                      </td>
                      <td style={cellCenter}>
                        {editPast ? (
                          <input
                            value={row.notes || ""}
                            onChange={(e)=>patchUnified(row, "notes", e.target.value)}
                            placeholder="Gate code 1234; meet at cul-de-sac"
                            style={inputCenter}
                          />
                        ) : (row.notes || "-")}
                      </td>
                      <td style={cellCenter}>
                        {editPast ? (
                          <input
                            value={sold.names.join(', ')}
                            onChange={()=>{}}
                            style={inputCenter}
                            placeholder="Customers Sold"
                            readOnly
                          />
                        ) : (
                          <>
                            <div style={{fontWeight:700}}>{sold.count}</div>
                            {sold.names.length>0 && (
                              <div style={quiet}>{sold.names.join(', ')}</div>
                            )}
                          </>
                        )}
                      </td>
                      {editPast && (
                        <td style={cellCenter}>
                          <button
                            className="btn outline"
                            style={{fontSize:11, padding:"4px 6px", lineHeight:1, color:"var(--accent)"}}
                            onClick={()=>{
                              if(window.confirm("Delete this row?")){
                                deleteUnified(row)
                              }
                            }}
                          >
                            Delete
                          </button>
                        </td>
                      )}
                    </tr>
                  )
                })}
                {editPast && (
                  <FutureAddRow
                    salesmen={salesmen}
                    onAdd={row => {
                      const next = [...readNeighborhoods(), row]
                      writeNeighborhoods(next)
                      setNeigh(next)
                      ;(async()=>{
                        try{
                          if (hasSupa){
                            await supa.from('neighborhood_assignments').upsert({
                              id: row.id,
                              seller_email: row.sellerEmail,
                              seller_name: row.sellerName,
                              neighborhood: row.neighborhood,
                              day: row.day || null,
                              notes: row.notes || null,
                              assigned_at: new Date().toISOString()
                            });
                          }
                        }catch(_e){}
                      })();
                    }}
                    isPast
                  />
                )}
              </tbody>
            </table>
          </div>
        </div>
      </div>
    </div>
  )
}

function FutureAddRow({ salesmen, onAdd, isPast }) {
  const [when, setWhen] = useState("");
  const [salesmanEmail, setSalesmanEmail] = useState("");
  const [street, setStreet] = useState("");
  const [notes, setNotes] = useState("");
  const [customersSold, setCustomersSold] = useState("");
  return (
    <tr>
      <td style={cellCenter}>
        <input
          value={when}
          onChange={e=>setWhen(e.target.value)}
          style={inputCenter}
          placeholder="Add When"
        />
      </td>
      <td style={cellCenter}>
        <select
          value={salesmanEmail}
          onChange={e=>setSalesmanEmail(e.target.value)}
          style={inputCenter}
        >
          <option value="">Add Salesman</option>
          {salesmen.map(u=>(
            <option key={u.email} value={u.email}>{u.name||u.email}</option>
          ))}
        </select>
      </td>
      <td style={cellCenter}>
        <input
          value={street}
          onChange={e=>setStreet(e.target.value)}
          style={inputCenter}
          placeholder="Add Street"
        />
      </td>
      <td style={cellCenter}>
        <input
          value={notes}
          onChange={e=>setNotes(e.target.value)}
          style={inputCenter}
          placeholder="Add Notes"
        />
      </td>
      {isPast && (
        <td style={cellCenter}>
          <input
            value={customersSold}
            onChange={e=>setCustomersSold(e.target.value)}
            style={inputCenter}
            placeholder="Customers Sold (optional)"
          />
        </td>
      )}
      <td style={cellCenter}>
        <button
          className="btn outline"
          onClick={()=>{
            if(!when || !salesmanEmail || !street){
              alert("When, Salesman, and Street required"); return;
            }
            const newRow = {
              id: crypto.randomUUID ? crypto.randomUUID() : String(Date.now()),
              sellerEmail: salesmanEmail,
              sellerName: salesmen.find(u=>u.email===salesmanEmail)?.name||salesmanEmail,
              neighborhood: street,
              day: when,
              notes: notes,
              assignedAt: Date.now()
            }
            if(isPast && customersSold && customersSold.trim().length>0){
              newRow.customersSold = customersSold.trim();
            }
            onAdd(newRow)
            setWhen(""); setSalesmanEmail(""); setStreet(""); setNotes(""); setCustomersSold("");
          }}
        >
          Add Row
        </button>
      </td>
    </tr>
  )
}
